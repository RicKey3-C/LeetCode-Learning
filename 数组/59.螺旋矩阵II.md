## 题目描述：
<font style="color:rgb(38, 38, 38);">给你一个正整数 </font>`<font style="color:rgba(38, 38, 38, 0.75);">n</font>`<font style="color:rgb(38, 38, 38);"> ，生成一个包含 </font>`1`<font style="color:rgb(38, 38, 38);"> 到 </font>`<font style="color:rgba(38, 38, 38, 0.75);">n</font><sup><font style="color:rgba(38, 38, 38, 0.75);">2</font></sup>`<font style="color:rgb(38, 38, 38);"> 所有元素，且元素按顺时针顺序螺旋排列的 </font>`<font style="color:rgba(38, 38, 38, 0.75);">n x n</font>`<font style="color:rgb(38, 38, 38);"> 正方形矩阵 </font>`<font style="color:rgba(38, 38, 38, 0.75);">matrix</font>`<font style="color:rgb(38, 38, 38);"> 。</font>

**<font style="color:rgb(38, 38, 38);">示例 1：</font>**

![](https://cdn.nlark.com/yuque/0/2024/jpeg/40932176/1725891313643-6d1cd249-e6ec-45e9-85de-a90b53afa525.jpeg)

```plain
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**<font style="color:rgb(38, 38, 38);">示例 2：</font>**

```plain
输入：n = 1
输出：[[1]]
```

示例3：

| 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- |
| 16 | 17 | 18 | 19 | 6 |
| 15 | 24 | | 20 | 7 |
| 14 | 23 | 22 | 21 | 8 |
| 13 | 12 | 11 | 10 | 9 |


## 解题思路：
本题看似简单，实则容易出错！得考虑清楚变量之间的关系，使用模拟的思路，要维护的变量众多：

1. 维护 loop 的次数，为n/2次；
2. 维护 startx,starty 初始为0，每一圈增加1；
3. 维护 offset（边界余量），为了平衡每次在各个方向上走的路程是有一样的，应该预留位置给下一条边；

然后通过loop去模拟为四条边赋值的情况，最后别忘了如果是奇数的情况要为 nums[mid][mid] 赋上最大值；

## 代码：
```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] nums = new int[n][n];

        int startx = 0, starty = 0, i = 0, j = 0;
        int count = 1, offset = 1;
        int loop = 0;
        int mid=n/2;
        while (loop++ < n / 2) {
            for (j = starty; j < n - offset; j++) {
                nums[startx][j] = count++;
            }
            for (i = startx; i < n - offset; i++) {
                nums[i][j] = count++;
            }
            for (; j > starty; j--) {
                nums[i][j] = count++;
            }
            for (; i > startx; i--) {
                nums[i][j] = count++;
            }
            offset++;
            startx++;
            starty++;
        }
        if (n % 2 == 1) {
            nums[mid][mid] = count;
        }
        return nums;
    }
}
```

